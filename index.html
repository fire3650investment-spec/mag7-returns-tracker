<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>美股七巨頭報酬追蹤（單月 / YTD）</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { margin: 20px; font-family: ui-sans-serif, system-ui, "Noto Sans TC", Arial, sans-serif; }
    h1 { margin-bottom: 12px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    label { font-weight: 600; }
    select, button { padding: 8px 10px; font-size: 14px; }
    #status { min-height: 1.5em; margin: 8px 0 16px; color: #666; }
    #status.ok { color: #0a7b58; }
    #status.error { color: #b00020; }
    canvas { max-width: 100%; height: 460px; }
    .note { font-size: 12px; color: #888; margin-top: 8px; }
  </style>
</head>
<body>
  <h1>美股七巨頭報酬追蹤</h1>

  <div class="row">
    <label for="yearSelect">年份</label>
    <select id="yearSelect"></select>

    <label for="monthSelect">月份</label>
    <select id="monthSelect"></select>

    <label for="modeSelect">顯示</label>
    <select id="modeSelect">
      <option value="monthly">單月報酬</option>
      <option value="ytd">年初至今（YTD）</option>
    </select>

    <button id="runBtn" type="button">查詢</button>
  </div>

  <div id="status">請選擇年份、月份與顯示類型後按「查詢」。</div>
  <canvas id="chart"></canvas>
  <div class="note">資料來源：Financial Modeling Prep（免費額度約 250 次/日）。正式上線請改走後端 Proxy 隱藏 API Key。</div>

  <script>
    // ===== 基本設定 =====
    const DEMO_MODE = false; // true = 用假資料；false = 連 FMP
    const API_KEY = "7xTUMOCGtNmymONqH2VM2i1OJE4qAU47";
    const FMP_BASE = "https://financialmodelingprep.com/api/v3";
    const TICKERS = ["AAPL","MSFT","GOOGL","AMZN","NVDA","TSLA","META"];

    const yearSelect  = document.getElementById("yearSelect");
    const monthSelect = document.getElementById("monthSelect");
    const modeSelect  = document.getElementById("modeSelect");
    const runBtn      = document.getElementById("runBtn");
    const statusEl    = document.getElementById("status");
    const chartEl     = document.getElementById("chart");

    // 快取：避免切換顯示時重抓
    // cache[key] = { rows: [{ticker, monthPct, ytdPct}], labelMonth, labelYTD }
    const cache = new Map();

    (function initUI(){
      const now = new Date();
      const thisYear = now.getUTCFullYear();
      for (let y = thisYear; y >= thisYear - 11; y--) {
        const opt = document.createElement("option");
        opt.value = String(y);
        opt.textContent = String(y);
        yearSelect.appendChild(opt);
      }
      for (let m = 1; m <= 12; m++) {
        const opt = document.createElement("option");
        opt.value = String(m).padStart(2, "0");
        opt.textContent = String(m);
        monthSelect.appendChild(opt);
      }
      // 預設上個月
      const prev = new Date(Date.UTC(thisYear, now.getUTCMonth() - 1, 1));
      yearSelect.value  = String(prev.getUTCFullYear());
      monthSelect.value = String(prev.getUTCMonth() + 1).padStart(2, "0");
    })();

    function ymdUTC(year, month /*1-12*/, day){
      return new Date(Date.UTC(year, month - 1, day));
    }
    function getMonthRangeISO(year, month /*"01"~"12"*/){
      const y = Number(year);
      const m = Number(month);
      const start = ymdUTC(y, m, 1);
      const end   = ymdUTC(y, m + 1, 1); // 自動跨年
      return {
        startISO: start.toISOString().slice(0,10),
        endISO: end.toISOString().slice(0,10)
      };
    }
    function getYearStartISO(year){
      return ymdUTC(Number(year), 1, 1).toISOString().slice(0,10);
    }

    // ===== 單檔取價（抓 1/1 ~ 月底全部日資料，一次算出 單月 & YTD）=====
    async function fetchStockBoth(ticker, year, month){
      if (DEMO_MODE){
        // 穩定假資料
        const { startISO, endISO } = getMonthRangeISO(year, month);
        const seedBase = Array.from(ticker + startISO).reduce((s,c)=>s+c.charCodeAt(0),0);
        const base = 120 + (seedBase % 80); // 120~199
        const monthPct = ((seedBase % 21) - 10) / 100; // -10%~+10%
        const seedY = Array.from(ticker + year).reduce((s,c)=>s+c.charCodeAt(0),0);
        const ytdPct = ((seedY % 41) - 20) / 100; // -20%~+20%
        return { ticker, monthPct, ytdPct };
      }

      const { endISO } = getMonthRangeISO(year, month);
      const yearStartISO = getYearStartISO(year);

      // 取該年到該月月底的所有歷史資料
      const url = `${FMP_BASE}/historical-price-full/${encodeURIComponent(ticker)}?from=${yearStartISO}&to=${endISO}&apikey=${API_KEY}`;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`${ticker} HTTP ${res.status}`);
      const json = await res.json();
      const arr = Array.isArray(json?.historical) ? json.historical : [];
      if (arr.length === 0) throw new Error(`${ticker} 無資料`);

      // 由舊到新
      arr.sort((a,b)=> a.date.localeCompare(b.date));

      // 當月的第一個與最後一個交易日
      const { startISO: mStartISO, endISO: mEndISO } = getMonthRangeISO(year, month);
      const monthRows = arr.filter(d => d.date >= mStartISO && d.date < mEndISO);
      if (monthRows.length === 0) throw new Error(`${ticker} 該月無交易資料`);

      const monthFirst = monthRows[0];
      const monthLast  = monthRows[monthRows.length - 1];
      const monthStartClose = Number(monthFirst.close);
      const monthEndClose   = Number(monthLast.close);

      // 年初第一個交易日
      const yearFirst = arr[0];
      const ytdStartClose = Number(yearFirst.close);

      if (![monthStartClose, monthEndClose, ytdStartClose].every(Number.isFinite)) {
        throw new Error(`${ticker} 價格缺失`);
      }

      const monthPct = (monthEndClose - monthStartClose) / monthStartClose;
      // YTD 到「該月最後交易日」
      const ytdPct   = (monthEndClose - ytdStartClose) / ytdStartClose;

      return { ticker, monthPct, ytdPct };
    }

    async function fetchAllTickers(year, month){
      const rows = [];
      for (const t of TICKERS){
        let tries = 0;
        while(tries < 3){
          try {
            if (tries === 0) await new Promise(r=>setTimeout(r, 200));
            const r = await fetchStockBoth(t, year, month);
            rows.push(r);
            break;
          } catch (e){
            tries++;
            if (tries >= 3) throw new Error(`${t} 查詢失敗：${e.message}`);
            await new Promise(r=>setTimeout(r, 500 * tries));
          }
        }
      }
      rows.sort((a,b)=>a.ticker.localeCompare(b.ticker));
      return rows;
    }

    // ===== Chart.js 繪圖 =====
    let chart;
    function renderChart(rows, year, month, mode /* 'monthly' | 'ytd' */){
      const labels = rows.map(d=>d.ticker);
      const data   = rows.map(d=>{
        const pct = mode === 'monthly' ? d.monthPct : d.ytdPct;
        return Number((pct * 100).toFixed(2));
      });

      const label = mode === 'monthly'
        ? `${year}/${month} 單月報酬`
        : `${year}/01~${month} 年初至今（YTD）`;

      if (chart) chart.destroy();
      const ctx = chartEl.getContext('2d');
      chart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label, data }] },
        options: {
          responsive: true,
          scales: { y: { ticks: { callback: v => `${v}%` } } },
          plugins: {
            tooltip: { callbacks: { label: (c)=> `${c.parsed.y}%` } },
            legend: { display: true }
          }
        }
      });
    }

    function makeCacheKey(year, month){
      return `${year}-${month}`;
    }

    async function handleQuery(){
      const year  = yearSelect.value;
      const month = monthSelect.value;
      const mode  = modeSelect.value;
      const key   = makeCacheKey(year, month);

      statusEl.className = "";
      statusEl.textContent = "查詢中…";

      try{
        let payload = cache.get(key);
        if (!payload){
          const rows = await fetchAllTickers(year, month);
          payload = {
            rows,
            labelMonth: `${year}/${month} 單月報酬`,
            labelYTD:   `${year}/01~${month} 年初至今（YTD）`
          };
          cache.set(key, payload);
        }
        renderChart(payload.rows, year, month, mode);
        statusEl.className = "ok";
        statusEl.textContent = "完成";
      }catch(err){
        console.error(err);
        statusEl.className = "error";
        statusEl.textContent = `查詢失敗：${err.message}`;
      }
    }

    runBtn.addEventListener("click", handleQuery);
    // 切換顯示類型時，若該年月已有快取，直接重畫
    modeSelect.addEventListener("change", ()=>{
      const key = makeCacheKey(yearSelect.value, monthSelect.value);
      const mode = modeSelect.value;
      const payload = cache.get(key);
      if (payload){
        renderChart(payload.rows, yearSelect.value, monthSelect.value, mode);
        statusEl.className = "ok";
        statusEl.textContent = "完成（切換顯示）";
      }
    });
  </script>
</body>
</html>
